---
description: Pull Story from GitHub, create worktree, execute tasks, create PR when complete
# GitHub: Prefer gh CLI; fallback to GitHub MCP if gh unavailable
scripts:
  sh: .specify/scripts/bash/jcttech/worktree-manager.sh --json
  ps: .specify/scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly
---

## User Input

```text
$ARGUMENTS
```

You **MUST** consider the user input before proceeding (if not empty).

**Supported flags:**
- `--auto-merge` - Enable SA/TL review and auto-merge after CI passes

## Overview

This command implements a Story by:
1. Creating/resuming a git worktree for isolated development
2. Setting the Story status to `status:in-progress`
3. Working through each task checkbox
4. Updating the issue as tasks complete
5. When all tasks complete, creating a PR with "Closes #NNN"
6. Optionally performing SA/TL review and auto-merge (with `--auto-merge`)
7. Cascade closing parent Spec/Epic when all children complete

## Outline

### 1. Select Story to implement

- If user provides Story number (e.g., "#102"), use that
- Otherwise, list open Stories:
  ```bash
  gh issue list --type Story --state open --json number,title,assignees,labels
  ```
- Show Stories with their task counts and current status labels

### 2. Check for existing worktree

```bash
.specify/scripts/bash/jcttech/worktree-manager.sh --check {story_number}
```

**If worktree exists:**
- Check worktree status (clean/dirty)
- If dirty, show modified files and ask: "Resume with uncommitted changes? [Y/n]"
- If clean, inform user: "Resuming Story #{number} in existing worktree"

**If worktree does not exist:**
- Proceed to create new worktree

### 3. Create worktree (if new)

```bash
.specify/scripts/bash/jcttech/worktree-manager.sh --create {story_number} --title "{story_title}"
```

This will:
- Generate branch name: `{story_number}-{slug}` (e.g., `102-jwt-token-service`)
- Create worktree at: `worktrees/102-jwt-token-service/`
- Base off main branch (or existing remote branch if continuing)

### 4. Update Story status label

```bash
gh issue edit {story_number} --remove-label "status:draft" --add-label "status:in-progress"
```

### 5. Fetch Story details

```bash
gh issue view {story_number} --json number,title,body,state,labels
```

### 6. Parse tasks from Story body

- Extract checkbox items: `- [ ] Task description`
- Track which are already completed: `- [x] Done task`
- Display task list to user

### 7. Work through tasks sequentially

**IMPORTANT: All file operations must occur within the worktree path**

For each unchecked task:
a. Display the task description
b. Change to worktree directory for implementation
c. Implement the task (write code, tests, etc.) **in the worktree**
d. Commit changes in the worktree:
   ```bash
   cd {worktree_path} && git add . && git commit -m "Task: {task_description}"
   ```
e. After completing, update the GitHub issue:
   ```bash
   gh issue edit {story_number} --body "{updated_body_with_checked_task}"
   ```
f. Push changes:
   ```bash
   cd {worktree_path} && git push -u origin {branch_name}
   ```

### 8. Check for architecture changes

After implementation, ask:
- Did implementation introduce new components?
- Did implementation change data flow?
- Were there decisions made during implementation?

If yes to any:
- Prompt to update `.docs/architecture.md`
- Prompt to record decision with `/jcttech.decision`

### 9. When all tasks complete

#### 9a. Create Pull Request

```bash
cd {worktree_path} && gh pr create \
  --title "[Story] {story_title}" \
  --body "Closes #{story_number}

## Summary
{summary_of_changes}

## Tasks Completed
{list_of_checked_tasks}

## Parent Spec
#{parent_spec_number}

---
_Generated by /jcttech.implement_" \
  --type Story
```

#### 9b. Update Story status

```bash
gh issue edit {story_number} --remove-label "status:in-progress" --add-label "status:in-review"
```

#### 9c. If `--auto-merge` flag is set

Perform SA/TL Review before merging:

**Story Alignment Check:**
- Verify all Story tasks are implemented (checkboxes checked)
- Verify acceptance criteria from Story description are met
- Check for scope creep - implementation should match specification

**Code Quality Check:**
- Check for obvious security vulnerabilities (injection, XSS, exposed secrets)
- Check for performance anti-patterns (N+1 queries, unbounded loops)
- Verify code is maintainable (reasonable complexity, clear naming)
- Verify appropriate error handling

**Test Coverage Check:**
- Verify tests exist for new functionality
- Verify tests are meaningful (not just smoke tests)
- Check that edge cases are considered

**Review Output:**
```
SA/TL Review for PR #{pr_number} (Story #{story_number})

Story Alignment: ✓ PASS / ✗ FAIL
  - {N}/{total} tasks implemented
  - Acceptance criteria: {status}

Code Quality: ✓ PASS / ✗ FAIL
  - Security: {status}
  - Performance: {status}
  - Maintainability: {status}

Test Coverage: ✓ PASS / ✗ FAIL
  - Tests added: {count}
  - Edge cases: {status}

CI Status: Checking...
```

**If review passes:**
- Wait for CI to complete
- If CI passes, execute: `gh pr merge {pr_number} --merge --auto`
- Report: "AUTO-MERGE APPROVED - PR will merge when CI passes"

**If review fails:**
- Report specific issues found
- PR remains open for manual intervention
- Do NOT auto-merge

#### 9d. Report completion

```
Story #{story_number} Implementation Complete!

Summary:
- {N}/{total} tasks completed
- Files created: {count}
- Files modified: {count}
- Tests added: {count}

PR Created: #{pr_number} ({pr_url})
Story Status: in-review

Worktree: worktrees/{branch_name}/
(Worktree will be cleaned up after PR merge)

{If auto-merge enabled:}
SA/TL Review: PASSED
Auto-merge: ENABLED - will merge when CI passes
```

### 10. Cascade Close Detection

When a Story's PR is merged and the Story closes:

```bash
# Get parent Spec from native GitHub relationship
PARENT_SPEC=$(gh issue view {story_number} --json parent -q '.parent.number')

# Check if all Stories in parent Spec are closed (using native parent relationship)
OPEN_STORIES=$(gh issue list --type Story --state open --json number,parent \
  -q "[.[] | select(.parent.number == ${PARENT_SPEC})] | length")

if [ "$OPEN_STORIES" -eq 0 ]; then
  echo "All Stories in Spec #${PARENT_SPEC} complete - closing Spec"
  gh issue close $PARENT_SPEC --comment "All Stories completed. Auto-closing Spec."

  # Check parent Epic (using native relationship)
  PARENT_EPIC=$(gh issue view $PARENT_SPEC --json parent -q '.parent.number')

  if [ -n "$PARENT_EPIC" ]; then
    OPEN_SPECS=$(gh issue list --type Spec --state open --json number,parent \
      -q "[.[] | select(.parent.number == ${PARENT_EPIC})] | length")

    if [ "$OPEN_SPECS" -eq 0 ]; then
      echo "All Specs in Epic #${PARENT_EPIC} complete - closing Epic"
      gh issue close $PARENT_EPIC --comment "All Specs completed. Auto-closing Epic."
    fi
  fi
fi
```

## Worktree Management

The agent can use these utility commands:

### List active worktrees
```bash
.specify/scripts/bash/jcttech/worktree-manager.sh --list
```

Output:
```json
[
  {"issue_number": 102, "branch": "102-jwt-token-service", "path": "worktrees/102-jwt-token-service", "status": "dirty", "modified_count": 3},
  {"issue_number": 103, "branch": "103-login-endpoint", "path": "worktrees/103-login-endpoint", "status": "clean"}
]
```

### Get worktree status
```bash
.specify/scripts/bash/jcttech/worktree-manager.sh --status {issue_number}
```

### Cleanup worktree (after PR merge)
```bash
.specify/scripts/bash/jcttech/worktree-manager.sh --cleanup {issue_number}
```

## Status Labels

| Label | Meaning | Set By |
|-------|---------|--------|
| `status:draft` | Story created, not started | /jcttech.plan |
| `status:in-progress` | Worktree active, tasks being implemented | /jcttech.implement (start) |
| `status:blocked` | Implementation blocked | Manual |
| `status:in-review` | PR created, awaiting merge | /jcttech.implement (complete) |

## Task Workflow Example

```
Story #102: Implement JWT Token Service
Worktree: worktrees/102-jwt-token-service/

Tasks:
[1/4] - [ ] Create JWTService class with sign/verify methods
[2/4] - [ ] Add token validation middleware
[3/4] - [ ] Implement refresh token flow
[4/4] - [ ] Write unit tests

Current task: Create JWTService class with sign/verify methods

Working in worktree: /project/worktrees/102-jwt-token-service/
[Implementation happens in worktree]

Task complete!
✓ Committed: "Task: Create JWTService class with sign/verify methods"
✓ Pushed to origin/102-jwt-token-service
✓ GitHub issue updated - Task 1/4 checked off

Continue to next task? [Y/n]
```

## Error Handling

### Worktree already exists with dirty state
```
Warning: Worktree for Story #102 has uncommitted changes:
  - src/auth.ts (modified)
  - src/utils.ts (modified)

Options:
1. Resume with current changes [r]
2. Stash changes and continue [s]
3. Abort [a]

Choice:
```

### Branch conflict
```
Error: Branch 102-jwt-token-service already exists and has diverged from main.

Options:
1. Rebase onto main [r]
2. Continue with current branch [c]
3. Create new branch with suffix [n]
4. Abort [a]

Choice:
```

### SA/TL Review Failure (auto-merge mode)
```
SA/TL Review for PR #105 (Story #102)

Story Alignment: ✓ PASS
Code Quality: ✗ FAIL
  - Security: ISSUE FOUND
    Line 45: Potential SQL injection in user query
Test Coverage: ✓ PASS

Decision: AUTO-MERGE BLOCKED
Reason: Code quality issues detected

The PR has been created but will NOT be auto-merged.
Please address the issues above and request manual review.
```

### Cascade close not triggered
```
Note: Story #102 closed but Spec #101 remains open.
Remaining Stories:
- #103 [Story] Create Login Endpoint (2/3 tasks) - in-progress
- #104 [Story] Add Token Refresh Flow (0/3 tasks) - draft
```
