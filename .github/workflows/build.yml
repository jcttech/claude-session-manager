name: Build

on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
    branches: [main]

env:
  CARGO_TERM_COLOR: always
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Detect which files changed to determine what jobs to run
  changes:
    runs-on: ubuntu-latest
    outputs:
      code: ${{ steps.filter.outputs.code }}
    steps:
      - uses: actions/checkout@v4

      - name: Check for code changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            code:
              - 'src/**'
              - 'Cargo.toml'
              - 'Cargo.lock'
              - 'Dockerfile'
              - '.dockerignore'
              - 'tests/**'

  build:
    runs-on: ubuntu-latest
    needs: changes
    # Build if:
    # - Version tag (always for releases)
    # - PR (always run CI on PRs)
    # - Main branch with code changes
    if: |
      startsWith(github.ref, 'refs/tags/v') ||
      github.event_name == 'pull_request' ||
      (github.ref == 'refs/heads/main' && needs.changes.outputs.code == 'true')
    outputs:
      sha_short: ${{ steps.vars.outputs.sha_short }}
    steps:
      - uses: actions/checkout@v4

      - name: Set outputs
        id: vars
        run: echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-cargo-

      - name: Build
        run: cargo build --release

      - name: Run clippy
        run: cargo clippy -- -D warnings

      - name: Run tests
        run: cargo test --all-features

      - name: Upload binary
        uses: actions/upload-artifact@v4
        with:
          name: session-manager
          path: target/release/session-manager

  docker:
    runs-on: ubuntu-latest
    needs: [changes, build]
    # Build Docker if:
    # - Version tag (always build for releases)
    # - Main branch AND code changed (skip for docs/workflow-only changes)
    if: |
      startsWith(github.ref, 'refs/tags/v') ||
      (github.ref == 'refs/heads/main' && needs.changes.outputs.code == 'true')
    permissions:
      contents: read
      packages: write
    outputs:
      image_exists: ${{ steps.check.outputs.exists }}
    steps:
      - uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if image already exists for this SHA
        id: check
        run: |
          SHA_SHORT=${{ needs.build.outputs.sha_short }}
          # Try to pull the manifest - if it exists, image was already built
          if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${SHA_SHORT} > /dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Image already exists for SHA ${SHA_SHORT}"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Image does not exist for SHA ${SHA_SHORT}, will build"
          fi

      - name: Set up Docker Buildx
        if: steps.check.outputs.exists != 'true'
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            # Always tag with SHA
            type=sha,prefix=
            # For main branch: also tag as latest
            type=raw,value=latest,enable={{is_default_branch}}
            # For version tags: semver variants (1.0.0, 1.0, 1)
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}},enable=${{ !startsWith(github.ref, 'refs/tags/v0.') }}

      - name: Build and push Docker image
        if: steps.check.outputs.exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Retag existing image (skip rebuild)
        if: steps.check.outputs.exists == 'true'
        run: |
          SHA_SHORT=${{ needs.build.outputs.sha_short }}
          SOURCE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${SHA_SHORT}"

          echo "Retagging existing image ${SOURCE}"

          # Parse the tags from metadata action and apply them
          TAGS="${{ steps.meta.outputs.tags }}"

          # Create a comma-separated list for imagetools
          TAG_ARGS=""
          for tag in $TAGS; do
            TAG_ARGS="${TAG_ARGS} -t ${tag}"
          done

          # Use imagetools to create new tags pointing to existing image
          docker buildx imagetools create ${TAG_ARGS} ${SOURCE}

          echo "Successfully retagged image with: $TAGS"

  release:
    runs-on: ubuntu-latest
    needs: [build, docker]
    # Only create releases for version tags
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - name: Download binary
        uses: actions/download-artifact@v4
        with:
          name: session-manager
          path: ./artifacts

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
          files: |
            ./artifacts/session-manager
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
